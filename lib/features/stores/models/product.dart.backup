/// Product review model
class ProductReview {
  final String id;
  final String userName;
  final String userAvatar;
  final double rating;
  final String comment;
  final DateTime date;

  const ProductReview({
    required this.id,
    required this.userName,
    required this.userAvatar,
    required this.rating,
    required this.comment,
    required this.date,
  });

  /// Formatted date string
  String get formattedDate {
    final now = DateTime.now();
    final difference = now.difference(date);

    if (difference.inDays > 30) {
      final months = (difference.inDays / 30).floor();
      return months == 1 ? 'hace 1 mes' : 'hace $months meses';
    } else if (difference.inDays > 7) {
      final weeks = (difference.inDays / 7).floor();
      return weeks == 1 ? 'hace 1 semana' : 'hace $weeks semanas';
    } else if (difference.inDays > 0) {
      return difference.inDays == 1
          ? 'hace 1 día'
          : 'hace ${difference.inDays} días';
    } else {
      return 'hoy';
    }
  }
}

/// Product seller information
class ProductSeller {
  final String id;
  final String name;
  final String avatar;
  final double rating;
  final int reviewCount;

  const ProductSeller({
    required this.id,
    required this.name,
    required this.avatar,
    required this.rating,
    required this.reviewCount,
  });

  /// Formatted rating string
  String get formattedRating => '$rating (${reviewCount}+ opiniones)';
}

/// Product model for store catalog
class Product {
  final String id;
  final String name;
  final String description;
  final double price;
  final String imageUrl;
  final List<String> additionalImages;
  final String category;
  final bool isAvailable;
  final int stock;
  final List<String> tags;
  final double rating;
  final int reviewCount;
  final List<ProductReview> reviews;
  final ProductSeller seller;

  // Discount/offer related fields
  final double? discountPrice;
  final DateTime? discountEndDate;
  final bool hasActiveOffer;
  final double effectivePrice;
  final int? storeId;
  final int? categoryId;

  const Product({
    required this.id,
    required this.name,
    required this.description,
    required this.price,
    required this.imageUrl,
    this.additionalImages = const [],
    required this.category,
    this.isAvailable = true,
    this.stock = 0,
    this.tags = const [],
    this.rating = 0.0,
    this.reviewCount = 0,
    this.reviews = const [],
    ProductSeller? seller,
    this.discountPrice,
    this.discountEndDate,
    this.hasActiveOffer = false,
    double? effectivePrice,
    this.storeId,
    this.categoryId,
  }) : seller =
           seller ??
           const ProductSeller(
             id: 'default',
             name: 'Vendedor',
             avatar: '',
             rating: 4.0,
             reviewCount: 10,
           ),
       effectivePrice = effectivePrice ?? price;

  /// Formatted price string
  String get formattedPrice => '\$${price.toStringAsFixed(2)}';

  /// Formatted effective price (considering discounts)
  String get formattedEffectivePrice =>
      '\$${effectivePrice.toStringAsFixed(2)}';

  /// Formatted discount price
  String get formattedDiscountPrice => discountPrice != null
      ? '\$${discountPrice!.toStringAsFixed(2)}'
      : formattedPrice;

  /// Check if product has a valid active discount
  bool get hasValidDiscount {
    if (!hasActiveOffer || discountPrice == null || discountEndDate == null) {
      return false;
    }
    return DateTime.now().isBefore(discountEndDate!);
  }

  /// Calculate discount percentage
  double get discountPercentage {
    if (!hasValidDiscount || discountPrice == null) return 0.0;
    return ((price - discountPrice!) / price * 100);
  }

  /// Formatted discount percentage
  String get formattedDiscountPercentage {
    if (!hasValidDiscount) return '';
    return '-${discountPercentage.toStringAsFixed(0)}%';
  }

  /// Check if product is in stock
  bool get inStock => stock > 0;

  /// All product images (main + additional)
  List<String> get allImages => [imageUrl, ...additionalImages];

  /// Rating breakdown for reviews
  Map<int, double> get ratingBreakdown {
    if (reviews.isEmpty) return {5: 0, 4: 0, 3: 0, 2: 0, 1: 0};

    final breakdown = <int, int>{5: 0, 4: 0, 3: 0, 2: 0, 1: 0};

    for (final review in reviews) {
      final rating = review.rating.round();
      breakdown[rating] = (breakdown[rating] ?? 0) + 1;
    }

    return breakdown.map(
      (key, value) => MapEntry(key, value / reviews.length * 100),
    );
  }

  /// Create Product from JSON
  factory Product.fromJson(Map<String, dynamic> json) {
    return Product(
      id: json['id']?.toString() ?? '',
      name: json['name'] ?? '',
      description: json['description'] ?? '',
      price: (json['price'] ?? 0).toDouble(),
      imageUrl: json['image_url'] ?? json['imageUrl'] ?? '',
      additionalImages:
          (json['additional_images'] ?? json['additionalImages'] ?? [])
              .map<String>((img) => img.toString())
              .toList(),
      category: json['category'] ?? '',
      isAvailable: json['is_available'] ?? json['isAvailable'] ?? true,
      stock: json['stock'] ?? 0,
      tags: (json['tags'] ?? []).map<String>((tag) => tag.toString()).toList(),
      rating: (json['rating'] ?? 0).toDouble(),
      reviewCount: json['review_count'] ?? json['reviewCount'] ?? 0,
      reviews: [], // Reviews are loaded separately
      seller: json['seller'] != null
          ? ProductSeller(
              id: json['seller']['id']?.toString() ?? '',
              name: json['seller']['name'] ?? 'Vendedor',
              avatar: json['seller']['avatar'] ?? '',
              rating: (json['seller']['rating'] ?? 4.0).toDouble(),
              reviewCount:
                  json['seller']['review_count'] ??
                  json['seller']['reviewCount'] ??
                  0,
            )
          : null,
    );
  }

  /// Convert Product to JSON
  Map<String, dynamic> toJson() {
    return {
      'id': id,
      'name': name,
      'description': description,
      'price': price,
      'image_url': imageUrl,
      'additional_images': additionalImages,
      'category': category,
      'is_available': isAvailable,
      'stock': stock,
      'tags': tags,
      'rating': rating,
      'review_count': reviewCount,
    };
  }
}
